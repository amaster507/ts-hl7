import Msg from '../src'
import { Store } from '../stores'

export interface ServerConfig {
  // The receiving server host name/ip
  host: string
  // The receiving server port
  port: number
  // Value to use in ACK MSH.3
  name: string
  // Value to use in ACK MSH.4
  organization: string
  // A Store configuration to save persistent messages
  store?: StoreConfig
  // TODO: add support for outbound connections including filters, transformers, and destinations
  route?: ServerRoute[]
}

interface StoreConfig {
  // The type of store to use. Currently only "surreal" is supported
  type: Store
  /**
   * The name of the table to use to store the messages in the database
   * This string can be static or can be a HL7 selector like "$MSH-9.1"
   */
  table?: string
  /**
   * The namespace to use to store the messages in the database
   * This string can be static or can be a HL7 selector like "$MSH-6"
   */
  namespace?: string
  /**
   * The namespace to use to store the messages in the database
   * This string can be static or can be a HL7 selector like "$MSH-5"
   */
  database?: string
  /**
   * Use this to override the autogenerated id of the db record.
   * This string is a HL7 selector like "$MSH-10" or "$PID-3-1"
   */
  id?: string
  // the uri of the database endpoint -- http://localhost:8000/rpc
  uri: string
}

// FIXME: Support different type of routes not just TCP
interface ServerRoute {
  // The destination server host name/ip
  host: string
  // The destination server port
  port: number
  // Filters, Transformers, and Stores to apply to the message
  // These will get applied sequentially.
  flows?: (FilterFlow | TransformFlow | StoreConfig)[]
  // Whether or not to wait for the previous Route to complete before starting this one.
  // Ignored on first Route
  wait?: boolean
  // Whether to use original message or final message from previous Route
  // Ignored on first Route
  // Defaults to true
  useOriginal?: boolean
  // Whether to queue messages to the destination or just drop them
  // TODO: add support for queueing. Need more options for this, TBD
  queue?: boolean
}

type FilterFlow = (msg: Msg) => boolean

type TransformFlow = (msg: Msg) => Msg
